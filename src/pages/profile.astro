---
import ListItem from "@components/ListItem.astro";
import PageLayout from "@layouts/PageLayout.astro";

// Datos iniciales 
let myList =  [];

if (typeof window !== 'undefined') {
  myList = JSON.parse(window.localStorage.getItem('myList')) || [];
}

const initialData = {
  user: {
    name: "John Doe",
    avatar: "https://i.pinimg.com/736x/71/f9/3c/71f93c372475d6f17db9833eadf7233a.jpg",
    banner: "https://i.pinimg.com/736x/ad/00/21/ad0021d12cd6ac7ba9a33f97e322593c.jpg",
    favoriteGenre: "Acción"
  },
  stats: {
    total: 0,
    watched: 0,
    pending: 0
  },
  myList: []
};
---

<PageLayout title="Perfil" description="Página de perfil del usuario">
  <article class="profile">
    <!-- Encabezado del perfil -->
    <section class="profile__header">
      <div class="profile__header__banner">
        <picture class="profile__header__banner__image">
          <img
            src={initialData.user.banner}
            alt="Banner de portada"
            id="user-banner"
          />
        </picture>
      </div>
      <div class="profile__header__info">
        <picture class="profile__header__info__avatar">
          <img
            src={initialData.user.avatar}
            alt="Avatar del usuario"
            id="user-avatar"
          />
        </picture>
        <p class="profile__header__info__name" id="username">{initialData.user.name}</p>
      </div>
    </section>

    <!-- Barra lateral de estadísticas -->
    <aside class="profile__sidebar">
      <div class="profile__sidebar__item">
        <p>Género Favorito</p>
        <p id="favorite-genre">{initialData.user.favoriteGenre}</p>
      </div>
      <div class="profile__sidebar__item">
        <p>Total Lista</p>
        <p id="total-count">{initialData.stats.total}</p>
      </div>
      <div class="profile__sidebar__item">
        <p>Total vistos</p>
        <p id="watched-count">{initialData.stats.watched}</p>
      </div>
      <div class="profile__sidebar__item">
        <p>Pendientes</p>
        <p id="pending-count">{initialData.stats.pending}</p>
      </div>
    </aside>

    <!-- Lista de series/animes -->
    <section class="profile__list">
      <h1 class="profile__list__title">Mi lista de series</h1>
      <div id="list-container">
        {myList.length == 0 ? (
      <div class="empty-state">       
        <p>No tienes animes en tu lista aún</p>
      </div>
    ) : (
      myList.map(item => (
        <ListItem
          id={item.id}
          urlPoster={item.image}
          name={item.title}
          progress={item.progress}
          platform={item.platform || 'No especificado'}
          draggable="true"
          client:load
        />
      ))
    )}
      </div>
    </section>
  </article>
</PageLayout>

<script is:inline>
  document.addEventListener('DOMContentLoaded', () => {
    // Keys de LocalStorage
    const USER_KEY = 'animeAppCurrentUser';
    const LIST_KEY = 'myList';

    // Elementos del DOM
    const container = document.getElementById('anime-list-container');
    const listContainer = document.getElementById('list-container') || container;

    // 1. Cargar datos del usuario
    const loadUserData = () => {
      const userData = JSON.parse(localStorage.getItem(USER_KEY)) || initialData.user;
      
      document.getElementById('user-avatar').src = userData.avatarUrl || userData.avatar;
      document.getElementById('user-banner').src = userData.bannerUrl || userData.banner;
      document.getElementById('username').textContent = userData.username || userData.name;
      document.getElementById('favorite-genre').textContent = userData.favoriteGenre || 'No especificado';
    };

    // 2. Cargar lista y estadísticas
    const loadListData = () => {
      const myList = JSON.parse(localStorage.getItem(LIST_KEY)) || [];
      
      // Actualizar estadísticas
      updateStats(myList);
      
      // Mostrar lista vacía o contenido
      if (myList.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <p>No tienes animes en tu lista aún</p>
          </div>
        `;
      }
    };

    // 3. Actualizar estadísticas
    const updateStats = (list) => {
      document.getElementById('total-count').textContent = list.length;
      document.getElementById('watched-count').textContent = 
        list.filter(item => item.progress === 100).length;
      document.getElementById('pending-count').textContent = 
        list.filter(item => item.progress < 100).length;
    };

    // 4. Configurar drag and drop (solo si hay elementos)
    const setupDragAndDrop = () => {
      const listContainer = document.querySelector(".profile__list");
      if (!listContainer) return;

      let draggedItem = null;

      const getDragAfterElement = (container, y) => {
        const draggableElements = [...container.querySelectorAll(".list-item:not(.dragging)")];
        return draggableElements.reduce(
          (closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            return offset < 0 && offset > closest.offset ? 
                   { offset, element: child } : closest;
          }, 
          { offset: Number.NEGATIVE_INFINITY }
        ).element;
      };

      document.querySelectorAll(".list-item").forEach(item => {
        item.addEventListener("dragstart", () => {
          draggedItem = item;
          item.classList.add("dragging");
        });

        item.addEventListener("dragend", () => {
          item.classList.remove("dragging");
        });
      });

      listContainer.addEventListener("dragover", (e) => {
        e.preventDefault();
        const afterElement = getDragAfterElement(listContainer, e.clientY);
        const currentList = JSON.parse(localStorage.getItem(LIST_KEY)) || [];

        if (afterElement) {
          listContainer.insertBefore(draggedItem, afterElement);
        } else {
          listContainer.appendChild(draggedItem);
        }

        // Actualizar LocalStorage con nuevo orden
        const items = Array.from(listContainer.querySelectorAll('.list-item'));
        const updatedList = items.map(item => {
          const id = parseInt(item.dataset.id);
          return currentList.find(anime => anime.id === id);
        }).filter(Boolean);

        localStorage.setItem(LIST_KEY, JSON.stringify(updatedList));
      });
    };

    // Inicialización
    loadUserData();
    loadListData();
    setupDragAndDrop();

    // Sincronización entre pestañas
    window.addEventListener('storage', (e) => {
      if (e.key === USER_KEY) loadUserData();
      if (e.key === LIST_KEY) loadListData();
    });
  });

  // Función auxiliar para debug
  function debugLocalStorage() {
    console.log('Usuario:', JSON.parse(localStorage.getItem('animeAppCurrentUser')));
    console.log('Lista:', JSON.parse(localStorage.getItem('myList')));
  }
</script>

<style>
	.profile {
		display: grid;
		grid-template-areas:
			"header"
			"sidebar"
			"list";
		grid-template-columns: 1fr;
		grid-template-rows: auto auto 1fr;
		padding: 0 3rem;

		.profile__header {
			grid-area: header;
			margin-top: -0.8rem;
			.profile__header__banner {
				height: 20dvh;
				border: 1px solid var(--indigo);
				border-radius: 1rem;
				.profile__header__banner__image {
					width: 100%;
					height: 100%;
					object-fit: cover;
					img {
						width: 100%;
						height: 100%;
						object-fit: cover;
						border-radius: 1rem;
					}
				}
			}
			.profile__header__info {
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				gap: 1rem;
				margin-top: -5rem;
				width: 100%;

				.profile__header__info__avatar {
					width: 150px;
					height: 150px;
					border-radius: 50%;
					border: 1px solid var(--indigo);
					overflow: hidden;
					img {
						width: 100%;
						height: 100%;
						object-fit: cover;
					}
				}
				.profile__header__info__name {
					font-weight: 700;
					text-transform: uppercase;
					font-size: 1.2rem;
					color: var(--indigo);
					text-align: center;
				}
			}
		}
		.profile__sidebar {
			grid-area: sidebar;
			width: 100%;
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 0.5rem;
			padding: 2rem 0.5rem;
			.profile__sidebar__item {
				min-width: 150px;
				text-align: center;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				border: 2px solid var(--indigo);
				color: var(--indigo);
				padding: 1rem;
				border-radius: 1rem;
				font-weight: 700;
				font-size: 1rem;
				user-select: none;
				transition: all 0.3s ease;
			}
			.profile__sidebar__item:hover {
				color: var(--white);
				background-color: var(--indigo);
			}
		}
		.profile__list {
			grid-area: list;
		}
	}

	@media screen and (min-width: 768px) and (max-width: 1024px) {
		.profile {
			grid-template-areas:
				"header header header"
				"sidebar list list";
			grid-template-columns: 1fr 2fr;
		}
	}

	@media screen and (min-width: 1024px) {
		.profile {
			grid-template-areas:
				"header header header"
				"sidebar list list";
			grid-template-columns: 30% 70%;
			grid-template-rows: auto 1fr;

			.profile__header {
				.profile__header__info {
					flex-direction: row;
					justify-content: flex-start;
					padding-left: 50px;
					gap: 1rem;
					margin-top: -5rem;
					width: 100%;
					.profile__header__info__name {
						font-size: 1.5rem;
						width: fit-content;
						padding: 0.5rem 1rem;
						border-radius: 0.5rem;
						background-color: color-mix(
							in oklch,
							var(--creamy-ivory) 80%,
							transparent
						);
						box-shadow: 0 0 10px
							color-mix(
								in oklch,
								var(--creamy-ivory) 50%,
								transparent
							);
					}
				}
			}
			.profile__sidebar {
				position: sticky;
				top: 1rem;
				align-self: start;
				display: flex;
				flex-direction: column;
			}
		}
	}
</style>

<!-- <script>
	const listContainer = document.querySelector(".profile__list");
	let draggedItem = null;

	document.querySelectorAll(".list__item").forEach((item) => {
		item.addEventListener("dragstart", () => {
			draggedItem = item;
			item.classList.add("dragging");
		});

		item.addEventListener("dragend", () => {
			draggedItem = null;
			item.classList.remove("dragging");
		});
	});

	listContainer.addEventListener("dragover", (e) => {
		e.preventDefault();
		const afterElement = getDragAfterElement(listContainer, e.clientY);
		if (afterElement == null) {
			listContainer.appendChild(draggedItem);
		} else {
			listContainer.insertBefore(draggedItem, afterElement);
		}
	});

	function getDragAfterElement(container, y) {
		const draggableElements = [
			...container.querySelectorAll(".list__item:not(.dragging)"),
		];

		return draggableElements.reduce(
			(closest, child) => {
				const box = child.getBoundingClientRect();
				const offset = y - box.top - box.height / 2;
				if (offset < 0 && offset > closest.offset) {
					return { offset: offset, element: child };
				} else {
					return closest;
				}
			},
			{ offset: Number.NEGATIVE_INFINITY }
		).element;
	}
</script> -->
